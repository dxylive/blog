<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thump-thump</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-05T10:35:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>春鱼未暖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Integer和int区别</title>
    <link href="http://yoursite.com/2019/11/05/Integer%E5%92%8Cint%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/05/Integer和int区别/</id>
    <published>2019-11-05T10:31:51.000Z</published>
    <updated>2019-11-05T10:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念区分"><a href="#基本概念区分" class="headerlink" title="基本概念区分"></a>基本概念区分</h3><p>1.Integer是int的包装类型，int是java的一种基本数据类型</p><p>2.Integer必须实例化后才能使用，int变量不需要</p><p>3.Integer是实际是对象的引用，当new一个Integer时，实际上是生成一个指向此对象，而int则是直接存储数据值</p><p>4.Integer默认值是null，int默认值是0</p><h3 id="Integer、new-Integer-和-int-的比较"><a href="#Integer、new-Integer-和-int-的比较" class="headerlink" title="Integer、new Integer() 和 int 的比较"></a>Integer、new Integer() 和 int 的比较</h3><p>1.<strong>两个new Integer（）比较永远是false</strong></p><ul><li>因为new生成的是两个对象，其内存地址不同</li></ul><p>2.<strong>Integer变量 和 new Integer() 变量比较 ，永远为 false</strong></p><ul><li>因为 Integer变量 指向的是 java 常量池 中的对象， 而 new Integer() 的变量指向 堆中 新建的对象，两者在内存中的地址不同。</li></ul><p>3.<strong>两个Integer 变量比较，如果两个变量的值在区间-128到127 之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为 false 。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>分析：Integer i = 100 在编译时，会翻译成为 Integer i = Integer.valueOf(100)，而 java 对 Integer类型的 valueOf 的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">   <span class="keyword">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">     <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存。所以 Integer i = 127 时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</p><p>4.<strong>int 变量 与 Integer、 new Integer() 比较时，只要两个的值是相等，则为true 因为包装类Integer 和 基本数据类型int 比较时，java会自动拆包装为int ，然后进行比较，实际上就变为两个int变量的比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>); </span><br><span class="line"><span class="comment">//自动拆箱为 int i=100; 此时，相当于两个int的比较</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.out.print(i == j); </span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念区分&quot;&gt;&lt;a href=&quot;#基本概念区分&quot; class=&quot;headerlink&quot; title=&quot;基本概念区分&quot;&gt;&lt;/a&gt;基本概念区分&lt;/h3&gt;&lt;p&gt;1.Integer是int的包装类型，int是java的一种基本数据类型&lt;/p&gt;
&lt;p&gt;2.Integer必
      
    
    </summary>
    
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>事务的几大概念</title>
    <link href="http://yoursite.com/2019/11/05/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E5%A4%A7%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/11/05/事务的几大概念/</id>
    <published>2019-11-05T10:31:51.000Z</published>
    <updated>2019-11-05T10:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><pre><code>事务A和事务B，同时获得相同数据，然后在各自的事务中修改数据M，事务A先提交事务，数据M假如为M+，事务B后提交事务，数据M变成了M++，最终结果变成M++覆盖了事务A的更新。</code></pre><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><pre><code>允许事务B可以读到事务A修改而未提交的数据可能会造成了脏读</code></pre><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><pre><code>不可重复读是指在一个事务范围中2次或者多次查询同一数据M返回了不同的数据 例如：事务B读取某一数据，事务A修改了该数据M并且提交，事务B又读取该数据M(可能是再次校验)，在同一个事务B中，读取同一个数据M的结果集不同，这个很蛋疼。</code></pre><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><pre><code>事务B读某一个数据M，事务A对数据M增加了一行并提交，事务B又读数据M，发生多出了一行造成的结果不一致(如果行数相同，则是不可重复读)。</code></pre><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><pre><code>对数据被外界修改保持保守态度，在整个数据处理过程中，数据处于锁定状态，依赖于数据库提供的锁机制。</code></pre><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><pre><code>具体做法：数据库表增加一个&quot;version&quot;字段来实现，读取数据时，将版本号一同读出，之后更新，对版本号加1，将提交数据的版本数据与数据库对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库的数据，则予以更新，否则，被认为是过期数据。</code></pre><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><ul><li>一级封锁协议<ul><li>对应<strong>READ-UNCOMMITTED</strong>隔离级别<br>  可能造成脏读，丢失更新，不可重复读，幻读</li></ul></li><li>二级封锁协议<ul><li>对应<strong>READ-COMMITTED</strong>隔离级别<br>  可能造成丢失更新，不可重复读，幻读</li></ul></li><li>三级封锁协议<ul><li>对应<strong>REPEATABLE-READ</strong>隔离级别<br>  可能造成丢失更新，幻读</li></ul></li><li>最强封锁协议<ul><li>对应<strong>Serialization</strong>隔离级别<br>  避免所有可能，造成的开销也是最大的  </li></ul></li></ul><h3 id="ANSI-SQL-隔离级级别"><a href="#ANSI-SQL-隔离级级别" class="headerlink" title="ANSI SQL 隔离级级别"></a>ANSI SQL 隔离级级别</h3><table><thead><tr><th>隔离性</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>READ-COMMITTED</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>REPEATABLE-READ</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>SERIALIZABLE</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table><h3 id="spring-tx中propagation传播行为的7种配置"><a href="#spring-tx中propagation传播行为的7种配置" class="headerlink" title="spring tx中propagation传播行为的7种配置"></a>spring tx中propagation传播行为的7种配置</h3><p><strong>REQUIRED</strong></p><ul><li>业务方法需要在一个事务中运行，如果方法运行时，已经处在一个事务中,要么加入到该事务，要么创建一个新事务</li></ul><p><strong>NOT_SUPPORTED</strong></p><ul><li>声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务。如果方法在一个方法中被调用，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行</li></ul><p><img src="https://images2015.cnblogs.com/blog/1078531/201703/1078531-20170328162510701-117456639.png" alt="img"></p><h3 id="rollbackFor的作用"><a href="#rollbackFor的作用" class="headerlink" title="rollbackFor的作用"></a>rollbackFor的作用</h3><p>简单来说，如果不设置 rollbackFor = Exception.class，则当方法抛出检查型异常时，数据库操作不会回滚</p><p>如果方法中声明了异常，则需要rollbackFor，如果方法中没有声明异常，则不需要</p><h3 id="传播行为中的Propagation-SUPPORTS作用"><a href="#传播行为中的Propagation-SUPPORTS作用" class="headerlink" title="传播行为中的Propagation.SUPPORTS作用"></a>传播行为中的Propagation.SUPPORTS作用</h3><p>简单来说，在单独执行外层没有事务的时候，该方法将以非事务的形式执行</p><ul><li><p>为什么要配置SUPPORTS</p><p>InnoDB引擎增加了<strong>对只读事务的优化</strong>，简单来说，InnoDB可以为只读事务避免创建事务id</p><p>进而避免事务的繁杂操作，</p></li></ul><p><strong>测试结果</strong>：</p><ul><li><strong>SUPPORTS</strong> + <strong>readOnly</strong>: 每次查询耗时约 3 ms</li><li>仅 <strong>SUPPORTS</strong>: 每次查询耗时大约 3 ms</li><li>默认事务配置（<strong>不加</strong> SUPPORTS 和 readOnly）: 每次查询耗时大约 10 ms</li><li>仅 <strong>readOnly</strong>: 每次查询耗时大约 17 ms</li></ul><p><strong>从测试结果来看，当时用 MySQL 5.6 + InnoDB 时，为 Spring 事务配置 Propagation.SUPPORTS 对读操作的性能提升最大；readOnly = true 不但没有性能提升，反而会造成性能下降，原因可能和额外的 set session transaction read only 操作有关。</strong></p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul><li><p>一致性</p></li><li><p>原子性 一个事务未提交时，发生错误就会rollback</p></li><li><p>隔离性：在并发事务下，多个事务有自己的独立了的事务空间，互不影响</p><p>隔离性引发的四大隔离级别，操控多个事务读取修改共享数据时的下的安全问题</p></li><li><p>持久性 如果事务执行成功后 在commit的过程中发生停电宕机的情况，在重新开机时，会自动回滚，然后将另外没有执行完的数据写入</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;丢失更新&quot;&gt;&lt;a href=&quot;#丢失更新&quot; class=&quot;headerlink&quot; title=&quot;丢失更新&quot;&gt;&lt;/a&gt;丢失更新&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;事务A和事务B，同时获得相同数据，然后在各自的事务中修改数据M，
事务A先提交事务，数据M假如为M+，事务B
      
    
    </summary>
    
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
