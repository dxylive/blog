<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thump-thump</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dxylive.top/"/>
  <updated>2020-03-02T13:01:45.432Z</updated>
  <id>http://dxylive.top/</id>
  
  <author>
    <name>春鱼未暖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>全表扫描的几种糟糕情况</title>
    <link href="http://dxylive.top/2020/01/20/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B3%9F%E7%B3%95%E6%83%85%E5%86%B5/"/>
    <id>http://dxylive.top/2020/01/20/全表扫描的几种糟糕情况/</id>
    <published>2020-01-20T06:20:32.000Z</published>
    <updated>2020-03-02T13:01:45.432Z</updated>
    
    <content type="html"><![CDATA[<p>​    开篇先说点题外话，博主的职业现在是做二维码交易的一名码农，在2019年末的时候，由于交易流水表中设置的一列没有索引而该列的数据有大量的空值，而那时刚入坑交易的我too young, too simple ,通过此列作为查询条件导致了全表扫描，而流水表的数据量很大，以亿级别的数据量进行全表查询，在上线1个小时左右后，数据库承受压力极大，开始出现大量的交易失败，所以下决心要恶补一下数据库的知识，下面进入正题</p><h3 id="什么情况下会让索引失效"><a href="#什么情况下会让索引失效" class="headerlink" title="什么情况下会让索引失效"></a>什么情况下会让索引失效</h3><ol><li><p><strong>模糊查询</strong></p><p>​      我们看到的模糊查询大多是这样的 like %_%,而左模糊（左面的%）会模糊匹配首字符，导致索引失效，模糊字段长度越大，效率越低，所以尽量在数据量大的表避免使用左模糊</p></li><li><p><strong>查询条件中含有is null的select语句</strong></p><p>​      is null 作为查询条件，那对应列不会出现在执行计划上，但是有意思的是 is not null 在选择率可以的情况下还是会出现在执行计划上的，那么问题来了，为什么is null会让索引无效但是is not null 有时却可以有效呢，问题点应该是出在了null这个特殊数据上。</p><p>​     了解一下B 树索引构建的过程，null值不会像其他取值一样出现在索引树的叶子节点上。这种情况是比较容易被证明的。我们在一些null值较多的列上建索引，会发现形成的索引树体积很小，与列值不相匹配。</p><p>​     最后可以得出一个结论，空值是不会进入索引的。</p></li><li><p><strong>or语句使用不正确</strong></p><p>​     or语句连接的条件中包含的列没有全部建立索引。</p></li><li><p><strong>update语句updata了全部字段</strong></p></li><li><p><strong>对于多张大数据量的表join</strong></p></li><li><p><strong>组合索引使用不当</strong></p></li></ol><p>​     查询条件中没有前导列，导致索引不起作用。<br>    ​     使用组合索引时，在排序时应按照组合索引中各列顺序进行排序（即使只有一个列需要排序），否则性能较差。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    开篇先说点题外话，博主的职业现在是做二维码交易的一名码农，在2019年末的时候，由于交易流水表中设置的一列没有索引而该列的数据有大量的空值，而那时刚入坑交易的我too young, too simple ,通过此列作为查询条件导致了全表扫描，而流水表的数据量很大，
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://dxylive.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>FeignClient源码理解</title>
    <link href="http://dxylive.top/2019/11/15/FeignClient%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>http://dxylive.top/2019/11/15/FeignClient源码理解/</id>
    <published>2019-11-15T07:13:24.000Z</published>
    <updated>2020-01-19T08:35:39.603Z</updated>
    
    <content type="html"><![CDATA[<p>   spring-cloud-fegin 是基于 netflix feign 做了封装，本文针对springcloud fegin使用及源码方向展开</p><h3 id="EnableFeignClients注解使用及源码解析"><a href="#EnableFeignClients注解使用及源码解析" class="headerlink" title="@EnableFeignClients注解使用及源码解析"></a>@EnableFeignClients注解使用及源码解析</h3><hr><ul><li>注解食用方法</li></ul><p>启动类上注解@EnableFeignClients 开启该module下的FeginClient配置类的注册服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注解源码解读</p><p> 现在我们看一下<strong>@EnableFeignClients</strong>注解，可以看出引入了<strong>FeignClientsRegistrar</strong>这个配置类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(FeignClientsRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableFeignClients</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而FeignClientsRegistrar这个配置类实现了<strong>spring</strong>中的<strong>ImportBeanDefinitionRegistrar</strong>接口中的<strong>registerBeanDefinitions</strong>方法，由此可以看出他是依赖于spring的初始化将注解进行解析加载</p><p>  我们以<strong>registerBeanDefinitions</strong>这个方法为入口，看一下里面的两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   registerDefaultConfiguration(metadata, registry);</span><br><span class="line">   registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法registerDefaultConfiguration()首先对于注解的类型进行判断，判断其是否为内部类或者方法内的本地类,如果是则获取该类名存入classname，<strong>registerClientConfiguration</strong>方法中将bean的名字，配置 包装成了<strong>FeignClientSpecification</strong>的builder注入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">   scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">   Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">   Map&lt;String, Object&gt; attrs = metadata</span><br><span class="line">         .getAnnotationAttributes(EnableFeignClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">   AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">         FeignClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">         : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">   <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">      scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">      basePackages = getBasePackages(metadata);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Set&lt;String&gt; clientClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">         basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">         clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">      &#125;</span><br><span class="line">      AbstractClassTestingTypeFilter filter = <span class="keyword">new</span> AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(ClassMetadata metadata)</span> </span>&#123;</span><br><span class="line">            String cleaned = metadata.getClassName().replaceAll(<span class="string">"\\$"</span>, <span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">return</span> clientClasses.contains(cleaned);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      scanner.addIncludeFilter(</span><br><span class="line">            <span class="keyword">new</span> AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">            .findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">         <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                  <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                  .getAnnotationAttributes(</span><br><span class="line">                        FeignClient<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line"></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            registerClientConfiguration(registry, name,</span><br><span class="line">                  attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line"></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个方法registerFeignClients()同样调用了<strong>registerClientConfiguration</strong>方法，该方法扫描的是@EnableFeignClients注解所在的目录子集下的<strong>所有@FeignClient注解所在的配置类的BeanDefinition</strong></p><p>ClassPathScanningCandidateComponentProvider，通过配置的过滤器来找出相应的结果,这里要判断是否是接口去拿到所有注解下的接口</p><p>继续registerFeignClients()中的最后一个方法<strong>registerFeignClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">      AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">   String className = annotationMetadata.getClassName();</span><br><span class="line">   BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">         .genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   validate(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"url"</span>, getUrl(attributes));</span><br><span class="line">   definition.addPropertyValue(<span class="string">"path"</span>, getPath(attributes));</span><br><span class="line">   String name = getName(attributes);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"name"</span>, name);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">   definition.addPropertyValue(<span class="string">"decode404"</span>, attributes.get(<span class="string">"decode404"</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallback"</span>, attributes.get(<span class="string">"fallback"</span>));</span><br><span class="line">   definition.addPropertyValue(<span class="string">"fallbackFactory"</span>, attributes.get(<span class="string">"fallbackFactory"</span>));</span><br><span class="line">   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">   String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be null</span></span><br><span class="line"></span><br><span class="line">   beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">   String qualifier = getQualifier(attributes);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      alias = qualifier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">         <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   该方法中创建了一个FeignClientFactoryBean格式的builder，这个格式实现了FactoryBean，用于spring创建bean，将这个格式的bean装配属性，这个bean为代理类，在spring实例化FeignClient时就会调用该代理bean的<strong>getObject方法</strong>去生成这个格式的bean</p><p>   下面一起看一下<strong>FeignClientFactoryBean</strong>的getObject()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   FeignContext context = applicationContext.getBean(FeignContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   Feign.Builder builder = feign(context);</span><br><span class="line"> <span class="comment">//如果没有url则走负载均衡，如果指定了url则通过Targeter类的target方法生成指定代理类</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      String url;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">         url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         url = <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;</span><br><span class="line">      url += cleanPath();</span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">            <span class="keyword">this</span>.name, url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">   &#125;</span><br><span class="line">   String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">   Client client = getOptional(context, Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">         <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">         <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">         client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">      &#125;</span><br><span class="line">      builder.client(client);</span><br><span class="line">   &#125;</span><br><span class="line">   Targeter targeter = get(context, Targeter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">         <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   首先实例化FeignContext对象，FeignContext对象在为主动实例化的情况下会走<strong>FeignAutoConfiguration</strong>配置类里自动装配<strong>FeignClientSpecification</strong>类中的配置</p><p>   然后生成feign的builder对象,我们追踪一下configureFeign中configureUsingConfiguration这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureUsingConfiguration</span><span class="params">(FeignContext context, Feign.Builder builder)</span> </span>&#123;</span><br><span class="line">   Logger.Level level = getOptional(context, Logger.Level<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="comment">//设置log级别</span></span><br><span class="line">   <span class="keyword">if</span> (level != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.logLevel(level);</span><br><span class="line">   &#125;</span><br><span class="line">   Retryer retryer = getOptional(context, Retryer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="comment">//设置重试策略</span></span><br><span class="line">   <span class="keyword">if</span> (retryer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.retryer(retryer);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//feign的错误code解析接口</span></span><br><span class="line">   ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (errorDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.errorDecoder(errorDecoder);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//超时时间设置，连接超时时间：connectTimeout默认10s，请求请求超时时间：readTimeout默认60s</span></span><br><span class="line">   Request.Options options = getOptional(context, Request.Options<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.options(options);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拦截器设置，可以看出拦截器也是可以针对单独的feignClient设置</span></span><br><span class="line">   Map&lt;String, RequestInterceptor&gt; requestInterceptors = context.getInstances(</span><br><span class="line">         <span class="keyword">this</span>.name, RequestInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (requestInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.requestInterceptors(requestInterceptors.values());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (decode404) &#123;</span><br><span class="line">      builder.decode404();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这里是对配置的参数进行设置的方法</p><p>接下来我们回到<strong>FeignClientFactoryBean</strong>这个类具体看一下负载均衡的实现</p><p>跟踪一下loadBalance这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断url是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">    <span class="keyword">this</span>.name, url));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(</span><br><span class="line">          <span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br></pre></td></tr></table></figure><p>判断@FeignClient中的url属性，来确定生成的负载均衡代理类</p><ul><li>如果为空，走默认ribbon代理类</li><li>如果不为空，走默认生成代理类的方式，指定url可以直接进行测试调用</li></ul><p>整个流程：Feign调用方发起请求，发送至hystrix的HystrixInvocationHandler，通过服务名称，找到对应方法的methodHandler，methodHandler中封装了loadBalanceClient、retryer、RequestInterceptor等组件，如果引入了sleuth,这几个组件均是sleuth的包装类。然后通过以上组件构造 <code>http</code>请求完成整个过程。</p><h3 id="注入spring容器"><a href="#注入spring容器" class="headerlink" title="注入spring容器"></a>注入spring容器</h3><p>总结：通过 <code>spring refresh()</code>方法，触发 <code>FeignClientFactoryBean.getObject()</code>方法获得了代理类，然后完成注入 <code>spring</code>容器的过程。该实现方式同 <code>Dubbo</code>的实现方式类似，有兴趣的可以自行研究噢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   spring-cloud-fegin 是基于 netflix feign 做了封装，本文针对springcloud fegin使用及源码方向展开&lt;/p&gt;
&lt;h3 id=&quot;EnableFeignClients注解使用及源码解析&quot;&gt;&lt;a href=&quot;#EnableFeig
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Integer和int区别</title>
    <link href="http://dxylive.top/2019/11/05/Integer%E5%92%8Cint%E5%8C%BA%E5%88%AB/"/>
    <id>http://dxylive.top/2019/11/05/Integer和int区别/</id>
    <published>2019-11-05T10:31:51.000Z</published>
    <updated>2019-11-05T10:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念区分"><a href="#基本概念区分" class="headerlink" title="基本概念区分"></a>基本概念区分</h3><p>1.Integer是int的包装类型，int是java的一种基本数据类型</p><p>2.Integer必须实例化后才能使用，int变量不需要</p><p>3.Integer是实际是对象的引用，当new一个Integer时，实际上是生成一个指向此对象，而int则是直接存储数据值</p><p>4.Integer默认值是null，int默认值是0</p><h3 id="Integer、new-Integer-和-int-的比较"><a href="#Integer、new-Integer-和-int-的比较" class="headerlink" title="Integer、new Integer() 和 int 的比较"></a>Integer、new Integer() 和 int 的比较</h3><p>1.<strong>两个new Integer（）比较永远是false</strong></p><ul><li>因为new生成的是两个对象，其内存地址不同</li></ul><p>2.<strong>Integer变量 和 new Integer() 变量比较 ，永远为 false</strong></p><ul><li>因为 Integer变量 指向的是 java 常量池 中的对象， 而 new Integer() 的变量指向 堆中 新建的对象，两者在内存中的地址不同。</li></ul><p>3.<strong>两个Integer 变量比较，如果两个变量的值在区间-128到127 之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为 false 。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>分析：Integer i = 100 在编译时，会翻译成为 Integer i = Integer.valueOf(100)，而 java 对 Integer类型的 valueOf 的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">   <span class="keyword">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">     <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存。所以 Integer i = 127 时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</p><p>4.<strong>int 变量 与 Integer、 new Integer() 比较时，只要两个的值是相等，则为true 因为包装类Integer 和 基本数据类型int 比较时，java会自动拆包装为int ，然后进行比较，实际上就变为两个int变量的比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>); </span><br><span class="line"><span class="comment">//自动拆箱为 int i=100; 此时，相当于两个int的比较</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.out.print(i == j); </span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念区分&quot;&gt;&lt;a href=&quot;#基本概念区分&quot; class=&quot;headerlink&quot; title=&quot;基本概念区分&quot;&gt;&lt;/a&gt;基本概念区分&lt;/h3&gt;&lt;p&gt;1.Integer是int的包装类型，int是java的一种基本数据类型&lt;/p&gt;
&lt;p&gt;2.Integer必
      
    
    </summary>
    
    
    
      <category term="java基础" scheme="http://dxylive.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>事务的几大概念</title>
    <link href="http://dxylive.top/2019/11/05/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%87%A0%E5%A4%A7%E6%A6%82%E5%BF%B5/"/>
    <id>http://dxylive.top/2019/11/05/事务的几大概念/</id>
    <published>2019-11-05T10:31:51.000Z</published>
    <updated>2019-11-05T10:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><pre><code>事务A和事务B，同时获得相同数据，然后在各自的事务中修改数据M，事务A先提交事务，数据M假如为M+，事务B后提交事务，数据M变成了M++，最终结果变成M++覆盖了事务A的更新。</code></pre><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><pre><code>允许事务B可以读到事务A修改而未提交的数据可能会造成了脏读</code></pre><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><pre><code>不可重复读是指在一个事务范围中2次或者多次查询同一数据M返回了不同的数据 例如：事务B读取某一数据，事务A修改了该数据M并且提交，事务B又读取该数据M(可能是再次校验)，在同一个事务B中，读取同一个数据M的结果集不同，这个很蛋疼。</code></pre><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><pre><code>事务B读某一个数据M，事务A对数据M增加了一行并提交，事务B又读数据M，发生多出了一行造成的结果不一致(如果行数相同，则是不可重复读)。</code></pre><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><pre><code>对数据被外界修改保持保守态度，在整个数据处理过程中，数据处于锁定状态，依赖于数据库提供的锁机制。</code></pre><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><pre><code>具体做法：数据库表增加一个&quot;version&quot;字段来实现，读取数据时，将版本号一同读出，之后更新，对版本号加1，将提交数据的版本数据与数据库对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库的数据，则予以更新，否则，被认为是过期数据。</code></pre><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><ul><li>一级封锁协议<ul><li>对应<strong>READ-UNCOMMITTED</strong>隔离级别<br>  可能造成脏读，丢失更新，不可重复读，幻读</li></ul></li><li>二级封锁协议<ul><li>对应<strong>READ-COMMITTED</strong>隔离级别<br>  可能造成丢失更新，不可重复读，幻读</li></ul></li><li>三级封锁协议<ul><li>对应<strong>REPEATABLE-READ</strong>隔离级别<br>  可能造成丢失更新，幻读</li></ul></li><li>最强封锁协议<ul><li>对应<strong>Serialization</strong>隔离级别<br>  避免所有可能，造成的开销也是最大的  </li></ul></li></ul><h3 id="ANSI-SQL-隔离级级别"><a href="#ANSI-SQL-隔离级级别" class="headerlink" title="ANSI SQL 隔离级级别"></a>ANSI SQL 隔离级级别</h3><table><thead><tr><th>隔离性</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>READ-COMMITTED</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>REPEATABLE-READ</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>SERIALIZABLE</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table><h3 id="spring-tx中propagation传播行为的7种配置"><a href="#spring-tx中propagation传播行为的7种配置" class="headerlink" title="spring tx中propagation传播行为的7种配置"></a>spring tx中propagation传播行为的7种配置</h3><p><strong>REQUIRED</strong></p><ul><li>业务方法需要在一个事务中运行，如果方法运行时，已经处在一个事务中,要么加入到该事务，要么创建一个新事务</li></ul><p><strong>NOT_SUPPORTED</strong></p><ul><li>声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务。如果方法在一个方法中被调用，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行</li></ul><p><img src="https://images2015.cnblogs.com/blog/1078531/201703/1078531-20170328162510701-117456639.png" alt="img"></p><h3 id="rollbackFor的作用"><a href="#rollbackFor的作用" class="headerlink" title="rollbackFor的作用"></a>rollbackFor的作用</h3><p>简单来说，如果不设置 rollbackFor = Exception.class，则当方法抛出检查型异常时，数据库操作不会回滚</p><p>如果方法中声明了异常，则需要rollbackFor，如果方法中没有声明异常，则不需要</p><h3 id="传播行为中的Propagation-SUPPORTS作用"><a href="#传播行为中的Propagation-SUPPORTS作用" class="headerlink" title="传播行为中的Propagation.SUPPORTS作用"></a>传播行为中的Propagation.SUPPORTS作用</h3><p>简单来说，在单独执行外层没有事务的时候，该方法将以非事务的形式执行</p><ul><li><p>为什么要配置SUPPORTS</p><p>InnoDB引擎增加了<strong>对只读事务的优化</strong>，简单来说，InnoDB可以为只读事务避免创建事务id</p><p>进而避免事务的繁杂操作，</p></li></ul><p><strong>测试结果</strong>：</p><ul><li><strong>SUPPORTS</strong> + <strong>readOnly</strong>: 每次查询耗时约 3 ms</li><li>仅 <strong>SUPPORTS</strong>: 每次查询耗时大约 3 ms</li><li>默认事务配置（<strong>不加</strong> SUPPORTS 和 readOnly）: 每次查询耗时大约 10 ms</li><li>仅 <strong>readOnly</strong>: 每次查询耗时大约 17 ms</li></ul><p><strong>从测试结果来看，当时用 MySQL 5.6 + InnoDB 时，为 Spring 事务配置 Propagation.SUPPORTS 对读操作的性能提升最大；readOnly = true 不但没有性能提升，反而会造成性能下降，原因可能和额外的 set session transaction read only 操作有关。</strong></p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ul><li><p>一致性</p></li><li><p>原子性 一个事务未提交时，发生错误就会rollback</p></li><li><p>隔离性：在并发事务下，多个事务有自己的独立了的事务空间，互不影响</p><p>隔离性引发的四大隔离级别，操控多个事务读取修改共享数据时的下的安全问题</p></li><li><p>持久性 如果事务执行成功后 在commit的过程中发生停电宕机的情况，在重新开机时，会自动回滚，然后将另外没有执行完的数据写入</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;丢失更新&quot;&gt;&lt;a href=&quot;#丢失更新&quot; class=&quot;headerlink&quot; title=&quot;丢失更新&quot;&gt;&lt;/a&gt;丢失更新&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;事务A和事务B，同时获得相同数据，然后在各自的事务中修改数据M，
事务A先提交事务，数据M假如为M+，事务B
      
    
    </summary>
    
    
    
      <category term="事务" scheme="http://dxylive.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
